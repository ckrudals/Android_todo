### 순차 탐색이란,  맨 앞에서 순서대로 탐색을 진행하는 알고리즘이다.

아래 예제 소스를 보면 실행 결과가 어떻게 될 것 같나?

```c
#include <stdio.h>

int Lsearch(int arr[], int len, int target) {
	int i;
	for (i = 0; i < len; i++) {
		if (arr[i] == target)
			return i;
	}
	return -1;
}

int main() {
	int arr[] = { 3,5,2,4,9 };
	int idx;

	idx = Lsearch(arr, sizeof(arr) / sizeof(int), 4);
	if (idx == -1)
		printf("탐색 실패\n");
	else
		printf("타켓 저장 인덱스: %d\n", idx);


	idx = Lsearch(arr, sizeof(arr) / sizeof(int), 7);
	if (idx == -1)
		printf("탐색 실패 \n");
	else {
		printf("타켓 저장 인덱스: %d\n", idx);
	}

}
```

실행 결과는 : 타켓 저장 인덱스: 3  
                  탐색 실패

라고 뜬다.

위의 소스를 토대로, **시간 복잡도를 분석해서 데이터의 수 n에 대한 연산횟수의 함수 T(n)를 구해보자**

이 알고리즘에 사용된 연산자는 <,++,==로 총 3개이다.  연산자의 사용이 적으면 적을수록,

좋은 알고리즘이라고 볼 수 있다.

그리고, 비교 연산의 사용이 줄어들면 줄어들수록 <과 ++ 연산의 수행횟수도 줄어들것이고 비교 연산의 사용횟수가 늘어나면 늘어날수록, <과 ++의 사용횟수가 늘어날 것이다.

그래서 다른연산들은 비교연산에 의도적이다.

우리는 == 비교연산에 집중적으로 볼 필요가 있다.

비교연산 횟수를 구해보자, 만약 찾고자 하는 값이 배열 맨앞에 있다면 수행 횟수가 1이 되고, 맨 뒤에 있다면 수행횟수는 n이 된다.

이렇게 최선의 경우(best case)와 최악의 경우(worse case) 가 있다.

데이터의 수가 많아지면 많아 질수록, 최악의 경우를 수행하게 되는 알고리즘은 큰 차이를 보인다.

따라서 알고리즘의 성능을 판다하기에 중요한 것은, 최악의 경우이다.

우리는 최선의 경우, 최악의 경우 가 아닌 평균적인 경우를 따지는게 더 효율적이다.

하지만, 평균적인 경우 라고 말하기에는 범위가 너무 광범위하게 잡혀있다. 그래서 논란의 소지가 거의 없는 최악의 경우

가 선택될 수 밖에 없다.

## 순차 탐색 알고리즘의 시간 복잡도 계산하기

### 최악의 경우 : 

데이터의 수가 n개일 때, 최악의 경우에 해당하는 연산횟수는 n이다.

따라서 T(n)=n 이다.

### 평균적인 경우:

계산하기 앞서, 가정 2개를 추가해야한다.

1\. 탐색 대상이 배열에 존재하지 않을 확률을 50%라고 가정한다.

2\. 배열의 첫 요소부터 마지막 요소까지, 탐색 대상이 존재할 확률은 동일하다.

만약 배열에 탐색 대상이 존재하지 않을 경우에, 데이터 수가 n개이면 총 n번의 비교연산을 수행한다고 하자.

팀섹 대상이 존재하지 않을 경우 : n

탐색 대상이 존재하는 경우의 연산횟수는 50%이므로 n/2, 2분의 1이다.

그런데 탐색 대상이 배열에 존재하는 경우, 존재하지 않은 경우의 확률이 50%이므로,

그 둘을 하나로 봐야한다.

nx1/2+n/2x1/2=3/4n이다.

따라서 T(n)=3/4n이다.